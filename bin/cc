#!/usr/bin/env bash
set -euo pipefail

# ===== „Ç∑„Ç∞„Éä„É´„Éè„É≥„Éâ„É™„É≥„Ç∞ =====
JOURNAL_SAVED=0
save_journal() {
  [[ "$JOURNAL_SAVED" == "1" ]] && return 0
  JOURNAL_SAVED=1

  # RUN_DIR „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
  [[ -z "${RUN_DIR:-}" ]] && return 0
  [[ -z "${RAW_LOG:-}" ]] && return 0

  local exit_code="${1:-130}"  # „Éá„Éï„Ç©„É´„Éà„ÅØ SIGINT

  python3 - "$DB" "$(printf "%s" "${TASK:-}" | head -c 800)" "$exit_code" "$(project_name 2>/dev/null || echo '')" "$(pwd)" "$RUN_DIR" <<'PY' 2>/dev/null || true
import sys
import sqlite3
import uuid
from datetime import datetime

db_path = sys.argv[1]
task = sys.argv[2]
exit_code = sys.argv[3]
project = sys.argv[4]
cwd = sys.argv[5]
run_dir = sys.argv[6]

j_id = f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}"
j_ts = datetime.now().isoformat()
j_result = f"exit_code={exit_code}"

conn = sqlite3.connect(db_path)
cur = conn.cursor()
cur.execute("""
    INSERT OR REPLACE INTO journal(id, ts, project, cwd, task, result, raw_ref)
    VALUES (?, ?, ?, ?, ?, ?, ?)
""", (j_id, j_ts, project, cwd, task[:800], j_result, run_dir))
conn.commit()
conn.close()
print(f"üìù Journal saved: {j_id}")
PY
}

cleanup() {
  save_journal "${EXIT_CODE:-130}"
}
trap cleanup EXIT

# ===== Ë®≠ÂÆö =====
CLAUDE_CMD="${CLAUDE_CMD:-claude}"  # „Åì„Åì„Çí„ÅÇ„Å™„Åü„ÅÆClaude Code CLIÂêç„Å´Âêà„Çè„Åõ„Çã
SYS_MD="$HOME/.claude/system/claude_code_memory.md"
DB="$HOME/.claude/db/memos.sqlite"
RUNS="$HOME/.claude/runs"

MEMO_DAILY_CAP="${CC_MEMO_DAILY_CAP:-50}"     # ÊàêÂäüÊôÇMemo„ÅÆ1Êó•‰∏äÈôê
MEMO_JUDGE="${CC_MEMO_JUDGE:-1}"             # 1=LLM„Ç∏„É£„ÉÉ„Ç∏ÊúâÂäπ
MEMO_RULE_GATE="${CC_MEMO_RULE_GATE:-1}"     # 1=„É´„Éº„É´„Ç≤„Éº„ÉàÊúâÂäπ


TOPK="${CC_TOPK:-5}"
LOG_TAIL="${CC_LOG_TAIL:-200}"
MEMO_ON_SUCCESS="${CC_MEMO_ON_SUCCESS:-0}" # 1„Å´„Åô„Çã„Å®ÊàêÂäüÊôÇ„ÇÇ‰øùÂ≠ò
ENABLE_GIT_DIFF="${CC_ENABLE_GIT_DIFF:-1}"
MAX_FIELD_CHARS="${CC_MAX_FIELD_CHARS:-800}"

# ===== ‰æùÂ≠ò„ÉÅ„Çß„ÉÉ„ÇØ =====
command -v sqlite3 >/dev/null 2>&1 || { echo "sqlite3 not found" >&2; exit 1; }
command -v python3 >/dev/null 2>&1 || { echo "python3 not found" >&2; exit 1; }
[[ -f "$SYS_MD" ]] || { echo "missing: $SYS_MD" >&2; exit 1; }
[[ -f "$DB" ]] || { echo "missing: $DB" >&2; exit 1; }

# „Çª„ÉÉ„Ç∑„Éß„É≥ÈÅ∏Êäû„É°„Éã„É•„ÉºË°®Á§∫
show_session_menu() {
  echo "„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:"
  echo "  1) Êñ∞Ë¶è„Çª„ÉÉ„Ç∑„Éß„É≥"
  echo "  2) Êó¢Â≠ò„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁ∂ôÁ∂ö"
  echo -n "ÈÅ∏Êäû [1/2]: "
  read -r choice
  case "$choice" in
    2)
      # Êó¢Â≠ò„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÁ∂ôÁ∂öÔºàClaude „ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Éî„ÉÉ„Ç´„Éº„Çí‰ΩøÁî®Ôºâ
      exec "$CLAUDE_CMD" --resume
      ;;
    1|"")
      # Êñ∞Ë¶è„Çª„ÉÉ„Ç∑„Éß„É≥Ôºà„Çø„Çπ„ÇØÂÖ•Âäõ„Å∏ÈÄ≤„ÇÄÔºâ
      echo "„Çø„Çπ„ÇØ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ (Ctrl+D „ÅßÁµÇ‰∫Ü):"
      TASK="$(cat)"
      ;;
    *)
      echo "ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô" >&2
      exit 1
      ;;
  esac
}

# „Çø„Çπ„ÇØÂÖ•Âäõ: ÂºïÊï∞ > „Éï„Ç°„Ç§„É´(-f) > stdin > ÂØæË©±ÂÖ•Âäõ
if [[ "${1:-}" == "-f" && -n "${2:-}" ]]; then
  # „Éï„Ç°„Ç§„É´„Åã„ÇâË™≠„ÅøËæº„Åø
  [[ -f "$2" ]] || { echo "File not found: $2" >&2; exit 2; }
  TASK="$(cat "$2")"
elif [[ -n "${*:-}" ]]; then
  # „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥ÂºïÊï∞„Åã„Çâ
  TASK="$*"
elif [[ ! -t 0 ]]; then
  # stdin „Åã„ÇâÔºà„Éë„Ç§„ÉóÂÖ•ÂäõÔºâ
  TASK="$(cat)"
else
  # ÂºïÊï∞„Å™„Åó„ÉªÂØæË©±„É¢„Éº„Éâ: „Çª„ÉÉ„Ç∑„Éß„É≥ÈÅ∏Êäû„É°„Éã„É•„Éº„ÇíË°®Á§∫
  show_session_menu
fi
[[ -n "$TASK" ]] || { echo 'Usage: cc "task" | cc -f file | echo "task" | cc' >&2; exit 2; }

mkdir -p "$RUNS"
RUN_ID="$(date +%Y%m%d_%H%M%S)"
RUN_DIR="$RUNS/$RUN_ID"
mkdir -p "$RUN_DIR"
RAW_LOG="$RUN_DIR/raw.log"
RECALL_TXT="$RUN_DIR/recall.md"
MEMO_JSON="$RUN_DIR/memo.json"

project_name() {
  if command -v git >/dev/null 2>&1 && git rev-parse --show-toplevel >/dev/null 2>&1; then
    basename "$(git rev-parse --show-toplevel)"
  else
    echo ""
  fi
}

strip_ansi() {
  # Remove ANSI escape codes from stdin
  sed -E 's/\x1b\[[0-9;]*[A-Za-z]//g; s/\x1b\][^\\]*\\//g; s/\x1b\[[?0-9;]*[hlm]//g'
}

mask_secrets() {
  # stdin -> stdout (ÂøÖË¶Å„Å™„ÇâËøΩÂä†Âº∑Âåñ)
  sed -E \
    -e 's/(Authorization:)[[:space:]]*Bearer[[:space:]]+[A-Za-z0-9._-]+/\1 Bearer [REDACTED]/gI' \
    -e 's/\b(ghp|gho|ghu|ghs|ghr)_[A-Za-z0-9]{20,}\b/[REDACTED_GITHUB_TOKEN]/g' \
    -e 's/\bya29\.[A-Za-z0-9._-]+\b/[REDACTED_GOOGLE_TOKEN]/g' \
    -e 's/\beyJ[A-Za-z0-9._-]+\b/[REDACTED_JWT]/g' \
    -e 's/\bAKIA[0-9A-Z]{16}\b/[REDACTED_AWS_ACCESS_KEY]/g' \
    -e 's/\bASIA[0-9A-Z]{16}\b/[REDACTED_AWS_ACCESS_KEY]/g'
}

truncate_field() {
  python3 - <<'PY'
import os,sys
s=sys.stdin.read()
n=int(os.environ.get("MAX_FIELD_CHARS","800"))
sys.stdout.write(s[:n])
PY
}

sql_escape() {
  python3 - <<'PY'
import sys
s=sys.stdin.read().replace("'", "''")
print(s, end="")
PY
}

build_query_text() {
  local task="$1"
  {
    echo "task: $task"
    echo "cwd: $(pwd)"
    echo "project: $(project_name)"
    echo "log_tail:"
    tail -n 50 "$RAW_LOG" 2>/dev/null | strip_ansi || true
    if [[ "$ENABLE_GIT_DIFF" == "1" ]] && command -v git >/dev/null 2>&1 && git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      echo "git_diff_stat:"
      git diff --stat 2>/dev/null | head -n 20 || true
    fi
  } | mask_secrets
}

recall_memos() {
  local q
  q="$(build_query_text "$TASK" | truncate_field)"

  # Á©∫„ÉªÁü≠„Åô„Åé„Çã„ÇØ„Ç®„É™„ÅØÊ§úÁ¥¢„Åó„Å™„ÅÑ
  if [[ -z "$(echo "$q" | tr -d '[:space:]')" || "${#q}" -lt 3 ]]; then
    return 0
  fi

  q="$(printf "%s" "$q" | sql_escape)"

  sqlite3 "$DB" <<SQL
.mode tabs
.headers off
SELECT m.id, m.project, m.tags, m.problem, m.fix, m.takeaway
FROM memos_fts f
JOIN memos m ON m.id = f.id
WHERE memos_fts MATCH '$q'
ORDER BY bm25(memos_fts) ASC
LIMIT $TOPK;
SQL
}

format_recall() {
  local rows="$1"
  {
    echo "## Related memory (auto-recalled)"
    echo
    if [[ -z "$rows" ]]; then
      echo "- (none)"
      echo
      return 0
    fi
    while IFS=$'\t' read -r id project tags problem fix takeaway; do
      [[ -z "$id" ]] && continue
      echo "- id: $id"
      [[ -n "$project" ]] && echo "  project: $project"
      [[ -n "$tags" ]] && echo "  tags: $tags"
      [[ -n "$problem" ]] && echo "  problem: $problem"
      [[ -n "$fix" ]] && echo "  fix: $fix"
      [[ -n "$takeaway" ]] && echo "  takeaway: $takeaway"
    done <<< "$rows"
    echo
  } > "$RECALL_TXT"
}

# ===== 1) recall =====
ROWS="$(recall_memos || true)"
format_recall "$ROWS"

# ===== 2) build context =====
CONTEXT="$(cat "$SYS_MD"; echo; cat "$RECALL_TXT")"
echo "$CONTEXT" > "$RUN_DIR/context.txt"
echo "## Current task" >> "$RUN_DIR/context.txt"
echo "$TASK" >> "$RUN_DIR/context.txt"

# ===== 3) run Claude Code (interactive mode) =====
# --append-system-prompt „Åß„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊ≥®ÂÖ•„Åó„ÄÅÂØæË©±„É¢„Éº„Éâ„ÇíÁ∂≠ÊåÅ
set +e
script -q "$RAW_LOG" "$CLAUDE_CMD" --append-system-prompt "$CONTEXT" "$TASK"
EXIT_CODE=$?
set -e

# ===== Journal: always append (facts only) =====
save_journal "$EXIT_CODE"

memo_daily_count() {
  sqlite3 "$DB" "SELECT COUNT(*) FROM memos WHERE ts >= datetime('now','start of day');"
}

rule_worthy() {
  # raw.log „Å® task „Åã„ÇâÂà§ÂÆöÔºàÈõë„Å´Âº∑„ÅÑ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊãæ„ÅÜÔºâ
  # 1=worthy 0=not
  local txt
  txt="$( (echo "$TASK"; tail -n 120 "$RAW_LOG" | strip_ansi) | tr -d '\r' | mask_secrets )"
  echo "$txt" | grep -Eqi \
    '„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà|„É™„Çπ„Éà|Ë™ø„Åπ„Å¶|Ë™øÊüª|‰∏ÄË¶ß|ÊâãÈ†Ü|„Çπ„ÉÜ„ÉÉ„Éó|ÂÜçÁô∫Èò≤Ê≠¢|ÊÅí‰πÖ|Âà§Êñ≠Âü∫Ê∫ñ|ËêΩ„Å®„ÅóÁ©¥|Ê≥®ÊÑèÁÇπ|ÂéüÂõ†|Âàá„ÇäÂàÜ„Åë|root cause|checklist|runbook|playbook|decision|trade-?off|pitfall' \
    && echo 1 || echo 0
}

llm_worthy_json() {
  # JSON„Åß { "worthy": true/false, "reason": "...", "tags": [...] } „ÇíËøî„Åï„Åõ„Çã
  # Â§±Êïó„Åó„Å¶„ÇÇÂÆâÂÖ®ÂÅ¥ÔºàfalseÔºâ„Å´ÂÄí„Åô
  local input
  input="$(
    {
      echo "Ê¨°„ÅÆÊÉÖÂ†±„Åã„Çâ„ÄÅ„Åì„ÅÆÂÜÖÂÆπ„Çí 'Èï∑Êúü„É°„É¢(Memo)' „Å®„Åó„Å¶‰øùÂ≠ò„Åô„Åπ„Åç„Åã„ÇíÂà§ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
      echo "Âá∫Âäõ„ÅØJSON„ÅÆ„Åø„ÄÇ„Çπ„Ç≠„Éº„Éû: {\"worthy\":true|false,\"reason\":\"Áü≠Êñá\",\"tags\":[\"...\"]}"
      echo "Âü∫Ê∫ñ: ÂÜçÂà©Áî®ÊÄß„ÅåÈ´ò„ÅÑ(Âà§Êñ≠Âü∫Ê∫ñ/ÊâãÈ†Ü/„ÉÅ„Çß„ÉÉ„ÇØ„É™„Çπ„Éà/ÊÅí‰πÖÂØæÁ≠ñ/ËêΩ„Å®„ÅóÁ©¥)„Å™„Çâ worthy=true„ÄÇ‰∏ÄËà¨Ë´ñ/‰∏ÄÊôÇÊÉÖÂ†±„Å™„Çâ false„ÄÇ"
      echo "Ê©üÂØÜ„ÅØÂê´„ÇÅ„Å™„ÅÑ„ÄÇ"
      echo
      echo "TASK:"
      echo "$TASK"
      echo
      echo "EXIT_CODE: $EXIT_CODE"
      echo
      echo "LOG_TAIL:"
      tail -n 160 "$RAW_LOG" | strip_ansi | mask_secrets
    } | truncate_field
  )"

  printf "%s\n" "$input" | "$CLAUDE_CMD" 2>/dev/null || echo '{"worthy":false,"reason":"judge_failed","tags":[]}'
}

# ===== 4) memoize (auto, guarded) =====
SHOULD_MEMO=0

if [[ "$EXIT_CODE" -ne 0 ]]; then
  SHOULD_MEMO=1
else
  # ÊàêÂäüÊôÇ„ÅØ‰∏äÈôê„Å®„Ç≤„Éº„Éà„ÅßÂà∂Âæ°
  CNT="$(memo_daily_count)"
  if [[ "$CNT" -lt "$MEMO_DAILY_CAP" ]]; then
    if [[ "$MEMO_RULE_GATE" == "1" ]] && [[ "$(rule_worthy)" == "1" ]]; then
      SHOULD_MEMO=1
    elif [[ "$MEMO_JUDGE" == "1" ]]; then
      JUDGE_JSON="$(llm_worthy_json)"
      # worthy Âà§ÂÆö
      if python3 - <<PY >/dev/null 2>&1
import json,sys
d=json.loads(sys.argv[1])
assert isinstance(d.get("worthy"), bool)
assert d["worthy"] in (True, False)
PY
      then
        if python3 - <<PY
import json,sys
d=json.loads(sys.argv[1])
print(1 if d.get("worthy") else 0)
PY
 "$JUDGE_JSON" | grep -q '^1$'; then
          SHOULD_MEMO=1
        fi
      fi
    fi
  fi
fi

if [[ "$SHOULD_MEMO" == "1" ]]; then
  # ===== Generate memo JSON using Claude =====
  MEMO_PROMPT="$(cat <<'PROMPT'
‰ª•‰∏ã„ÅÆÊÉÖÂ†±„Åã„Çâ„ÄåÊ¨°Âõû„ÅÆËá™ÂàÜ„ÅåÁ¢∫ÂÆü„Å´Âæó„Çí„Åô„ÇãÂ≠¶„Å≥„Äç„Çí1‰ª∂„Å†„ÅëJSON„ÅßÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

Âé≥ÂÆà‰∫ãÈ†Ö:
- Âá∫Âäõ„ÅØJSON„ÅÆ„ÅøÔºàÂâçÂæå„Å´Ë™¨ÊòéÊñá„Çí‰ªò„Åë„Å™„ÅÑÔºâ
- ÂêÑ„Éï„Ç£„Éº„É´„Éâ„ÅØ1„Äú3Êñá„Åæ„Åß
- Êé®Ê∏¨„ÉªÊÜ∂Ê∏¨„ÅØÁ¶ÅÊ≠¢
- ‰∏ÄÊôÇÁöÑ„Éª„Åù„ÅÆÂ†¥Èôê„Çä„ÅÆÊÉÖÂ†±„ÅØÁ¶ÅÊ≠¢
- Ê©üÂØÜÊÉÖÂ†±„ÉªË™çË®ºÊÉÖÂ†±„Éª„Éà„Éº„ÇØ„É≥„ÅØÂøÖ„Åö [REDACTED]
- ÂÜçÂà©Áî®„Åß„Åç„Å™„ÅÑÂÜÖÂÆπ„Å™„Çâ {"skip": true, "reason": "ÁêÜÁî±"} „ÇíÂá∫Âäõ

JSON Schema:
{
  "id": "‰∏ÄÊÑè„Å™IDÔºàtimestampÊé®Â•®Ôºâ",
  "ts": "ISO8601",
  "project": "‰ªªÊÑèÔºàrepoÂêç„Å™„Å©Ôºâ",
  "tags": ["ÊäÄË°ìË¶ÅÁ¥†", "ÂéüÂõ†", "„Ç´„ÉÜ„Ç¥„É™"],
  "problem": "‰Ωï„ÅåËµ∑„Åç„Åü„ÅãÔºà‰∫ãÂÆü„ÅÆ„ÅøÔºâ",
  "fix": "‰Ωï„Çí„Åó„Åü„ÇâËß£Ê±∫„Åó„Åü„ÅãÔºàÁ¢∫ÂÆö‰∫ãÈ†Ö„ÅÆ„ÅøÔºâ",
  "takeaway": "Ê¨°Âõû„ÅÆÂà§Êñ≠Âü∫Ê∫ñ„Éª„ÉÅ„Çß„ÉÉ„ÇØ„Éù„Ç§„É≥„Éà",
  "context": "OS / Ë®ÄË™û / ÂÆüË°åÁí∞Â¢ÉÔºàÁü≠ÊñáÔºâ"
}

PROMPT
)"

  MEMO_INPUT="$(
    {
      echo "$MEMO_PROMPT"
      echo
      echo "=== ÂÖ•ÂäõÊÉÖÂ†± ==="
      echo "TASK: $TASK"
      echo "EXIT_CODE: $EXIT_CODE"
      echo "PROJECT: $(project_name)"
      echo "CWD: $(pwd)"
      echo "OS: $(uname -s) $(uname -r)"
      echo
      echo "LOG_TAIL:"
      tail -n 200 "$RAW_LOG" 2>/dev/null | strip_ansi | mask_secrets | truncate_field
    }
  )"

  MEMO_RAW="$(printf "%s\n" "$MEMO_INPUT" | "$CLAUDE_CMD" -p 2>/dev/null || echo '{"skip":true,"reason":"generation_failed"}')"
  echo "$MEMO_RAW" > "$MEMO_JSON"

  # ===== Validate and insert memo =====
  python3 - "$MEMO_RAW" "$DB" "$RUN_DIR" "$(project_name)" "$(pwd)" <<'PY'
import json
import sys
import sqlite3
from datetime import datetime

raw = sys.argv[1]
db_path = sys.argv[2]
run_dir = sys.argv[3]
project = sys.argv[4]
cwd = sys.argv[5]

# Extract JSON from response (handle markdown code blocks)
json_str = raw.strip()
if json_str.startswith("```"):
    lines = json_str.split("\n")
    json_str = "\n".join(lines[1:-1] if lines[-1].startswith("```") else lines[1:])

try:
    memo = json.loads(json_str)
except json.JSONDecodeError:
    print(f"Invalid JSON: {raw[:200]}", file=sys.stderr)
    sys.exit(0)

# Check if skipped
if memo.get("skip"):
    print(f"Memo skipped: {memo.get('reason', 'unknown')}", file=sys.stderr)
    sys.exit(0)

# Validate required fields
required = ["problem", "fix", "takeaway"]
if not all(memo.get(f) for f in required):
    print(f"Missing required fields: {required}", file=sys.stderr)
    sys.exit(0)

# Generate ID and timestamp if not provided
memo_id = memo.get("id") or datetime.now().strftime("%Y%m%d_%H%M%S")
memo_ts = memo.get("ts") or datetime.now().isoformat()
tags = ",".join(memo.get("tags", [])) if isinstance(memo.get("tags"), list) else memo.get("tags", "")

# Insert into DB
conn = sqlite3.connect(db_path)
cur = conn.cursor()
cur.execute("""
    INSERT OR REPLACE INTO memos (id, ts, project, cwd, tags, problem, fix, takeaway, context, raw_ref)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
""", (
    memo_id,
    memo_ts,
    memo.get("project") or project,
    cwd,
    tags,
    memo.get("problem", ""),
    memo.get("fix", ""),
    memo.get("takeaway", ""),
    memo.get("context", ""),
    run_dir
))
conn.commit()
conn.close()
print(f"‚úÖ Memo saved: {memo_id}")
PY

fi
